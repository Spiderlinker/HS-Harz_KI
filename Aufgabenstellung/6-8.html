<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>

<BODY BGCOLOR="orange">
<CENTER>
  <H3>Laboraufgaben zu <EM>Künstliche Intelligenz</EM></H3>
  <A HREF="http://fstolzenburg.hs-harz.de/">Frieder Stolzenburg</A><BR>
  Abgabe bis spätestens zwei Tage vor dem nächsten Labor
</CENTER>

<P><B>AUFGABE 6:</B>
Drei Missionare und drei Kannibalen versuchen, einen Fluss zu überqueren. Sie
besitzen ein Boot, mit dem jeweils ein oder zwei Personen übersetzen können.
Falls irgendwann an einem Ort die Zahl der Kannibalen größer ist als die der
Missionare, fressen die Kannibalen die Missionare auf. Planen Sie die Überfahrt
so, dass alle Missionare und alle Kannibalen wohlbehalten am anderen Ufer
ankommen.</P>

<UL>
   <LI> Lösen Sie das Problem mittels eines Prolog-Programms! Das
	Programm soll auch die Lösung ausgeben.
   <LI> Repräsentieren Sie das Wissen geeignet! Vermeiden Sie
	Redundanzen!
   <LI> Es soll kein Zustand mehrfach durchlaufen werden. Um dies
	sicher zu stellen, können Sie das eingebaute Prädikat
	<EM>\+</EM> für die Negation verwenden.
</UL>

<B>Hinweis:</B> Um Ergebnisse in voller Länge ausgegeben zu bekommen, sollte im
Programm zu Anfang die Direktive
<EM>:- set_prolog_flag(answer_write_options,[max_depth(100)]).</EM>
eingesetzt werden.

<P><B>AUFGABE 7:</B> <!-- Künstliche Intelligenz 1999: 3 -->
Gegeben sei der Graph G<SUB>N</SUB> bestehend aus einem
Startknoten <EM>start</EM> und den folgenden Knoten:
<UL>
   <LI> <EM>incest(I,J)</EM> für I=0,1 und J=1,..,N
   <LI> <EM>cycle(K)</EM> für K=1,2
   <LI> <EM>tree(L)</EM> für L=1,..,2<SUP>N</SUP>-1
</UL>
Zwischen den Knoten bestehen folgende Verbindungen:
<UL>
   <LI> <EM>start~incest(0,1)<EM>, </EM>start~incest(1,1)</EM>
   <LI> <EM>incest(I,J)~incest(I',J+1)</EM> für I,I'=0,1 und J < N
   <LI> <EM>incest(1,N)~cycle(1)</EM>
   <LI> <EM>cycle(1)~cycle(2)</EM>, </EM>cycle(2)~cycle(1)</EM>
   <LI> <EM>cycle(2)~tree(1)</EM>
   <LI> <EM>tree(L)~tree(2L)</EM>, <EM>tree(L)~tree(2L+1)</EM>
        für L < 2<SUP>N-1</SUP>
</UL>
Dabei bedeutet die Schreibweise <EM>u~v</EM>, dass es eine
Verbindungskante von Knoten <EM>u</EM> nach <EM>v</EM> gibt (aber
nicht notwendigerweise umgekehrt).
<OL>
   <LI> Definieren Sie den Graphen G<SUB>3</SUB> in Prolog durch
	Fakten zum Prädikat <EM>edge/2</EM> für die Kanten. Der
	Startknoten <EM>S</EM> sei durch das Faktum
	<EM>init(S).</EM> gegeben.
   <LI> Programmieren Sie Tiefen- und Breitensuche in Graphen
	explizit in Prolog. Definieren Sie ein Prädikat
	<EM>search/2</EM>, welches im zweiten Argument alle vom
	Startknoten aus erreichbaren Knoten nacheinander durch
	Backtracking berechnet, und zwar in der durch die
	Suchstrategie (= erstes Argument) festgelegten
	Reihenfolge.
   <LI> In welcher Reihenfolge werden bei Tiefen- und
	Breitensuche die Knoten im Graphen G<SUB>3</SUB> besucht?
	Zeichnen Sie gegebenenfalls den Graphen G<SUB>3</SUB>!
</OL>
<B>Hinweise:</B>
<UL>
   <LI> Sie können das Prolog-Prädikat <EM>between(From,To,K)</EM> einsetzen,
	welches nacheinander in <EM>K</EM> die ganzen Zahlen zwischen
	<EM>From</EM> und <EM>To</EM> einschließlich aufzählt.
   <LI> Um Knoten in eine Queue oder einen Stack einzufügen, ist es
	sinnvoll, alle Nachfolgerknoten auf einmal berechnen zu können.
	Das kann man mit dem eingebauten Prädikat <EM>findall</EM> wie
	folgt realisieren: <EM>children(PARENT,CHILDREN) :- findall(CHILD,edge(PARENT,CHILD),CHILDREN).</EM>
   <LI> Jeder Knoten soll nur genau einmal berechnet werden, d.h. bauen Sie eine
	Schleifenerkennung ein und vermeiden so Endlosschleifen.
</UL>
</P>

<P><B>AUFGABE 8:</B>
Lösen Sie das unten stehende kryptoarithmethische Puzzle mit
Hilfe von Constraints über endlichen Domänen.<BR> Wie lange
braucht Ihr Programm, bis die Lösung gefunden wird? Vergleichen
Sie die Zeit mit einer Lösung ohne Constraint-Programmierung!</P>
<PRE>
      S E N D
    + M O R E
    ---------
    M O N E Y
</PRE>
<B>Hinweis:</B> Laufzeiten können Sie in SWI-Prolog mit Hilfe des Prädikats
<EM>time/1</EM> bestimmen.

</BODY>
</HTML>
